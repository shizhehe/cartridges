

% Content from: figures/ablations/ablations.tex

\begin{figure*}[t!]
    \centering
    \includegraphics[width=\textwidth]{figures/ablations/ablations-fig.pdf}
    \caption{
        \textbf{Ablating \artifact and \method design choices.}
        Ablations were performed on the \mtob dataset (see \Cref{app:results} for full ablation experiments).
        (\textbf{Left}) We train \artifacts using two different parameterizations: simplified prefix-tuning (as described in \Cref{sec:artifact-parameterization}) and low-rank adaptation (LoRA)~\cite{hu2022lora}. The $x$-axis shows accuracy on MMLU and the $y$-axis shows accuracy on the target dataset. Each point represents a different \artifact size.
        \textbf{Center} We train \artifacts with \method using two loss functions: a next token prediction loss (green) and a distillation loss (blue). The $x$ axis is the number of training steps, and the $y$ axis is accuracy. Each hue represents a different \artifact size.
        (\textbf{Right}) We generate synthetic data according to \Cref{alg:synthetic-generation} and ablate the choice of seed prompts sampled on Line 2. We consider two approaches: using a single, broad seed prompt (Green) or randomly sampling one of five different types of seed prompts (Blue). The $x$ axis is the number of training steps, and the $y$ axis is accuracy.
        }
    \label{fig:ablations}
    \vspace{-2mm}
\end{figure*}


% Content from: figures/banner/banner.tex

\begin{figure*}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/banner/banner-fig.pdf}
    \caption{
        \textbf{Producing \artifacts via self-study}. For a given document corpus, we train a \artifact by distilling the corpus into a parameterized KV cache through a process we call \method. At inference time, this \artifact can be loaded into an LLM, which can then be used to answer diverse queries about the corpus, simulating in-context analysis of the corpus while requiring substantially less memory.
    }
    \label{fig:banner}
\vspace{-3mm}
\end{figure*}


% Content from: figures/comparison/comparison_table.tex

\begin{figure}[t!]
\centering
\scalebox{0.9}{
\setlength{\tabcolsep}{4pt}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textit{Method} &
\begin{tabular}[c]{@{}c@{}}Consumes limited \\ memory \end{tabular} &
\begin{tabular}[c]{@{}c@{}}Retains corpus  \\ information\end{tabular} &
\begin{tabular}[c]{@{}c@{}}Supports diverse \\ prompts \end{tabular} &\\
\midrule
In-context learning
& \xmark & \cmark & \cmark  \\
Prompt / KV cache compression
& \cmark & \xmark & \cmark \\
\artifact + Next-token-prediction
& \cmark & \cmark & \xmark  \\
\rowcolor[HTML]{EFEFEF}  \artifact + \method
& \cmark & \cmark & \cmark\\
\bottomrule
\end{tabular}
}
\caption{\small \textbf{Comparing KV caching strategies.} \artifact improves memory efficiency, while retaining the quality of in-context learning across a broad set of prompts. \cmark~ indicates a strength and \xmark~ indicates a limitation.}
\end{figure}


% Content from: figures/composition/composition.tex

\begin{figure*}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/composition/plot.pdf}
    \caption{
        \textbf{\artifact Composition.}
        (\textbf{Left}) Illustration of \artifact composition, where two independently trained \artifacts (one for a Pepsi 10-K and one for an AMD 10-K) are concatenated without any additional training.
        (\textbf{Middle}) We evaluate composition on a dataset of multi-document questions requiring information in two different $\approx$100k token documents with \llamathreeb~(see \Cref{app:datasets}).
        The $x$-axis shows log-perplexity (lower is better) on gold-standard answers.
        We compare \artifact composition with an (a) ICL baseline where we truncate the document to fit in the 128k token context length and (b) an \artifact baseline where we only include the \artifact for one of the documents.
        (\textbf{Right}) Examples of responses to multi-document questions using composed cartridges.
    }
    \label{fig:composition}
\vspace{-2mm}
\end{figure*}


% Content from: figures/freeze/freeze.tex

\begin{figure*}[ht]
    \centering
    \includegraphics[width=\textwidth]{figures/freeze/freeze-fig.pdf}
    \caption{\textbf{Freezing the attention sink}. In both plots, the y-axis is accuracy and the x-axis is training step. The green line which corresponds to a run where we allow a trainable first token. (\textbf{Left}) The y-axis MMLU accuracy. This plot exemplifies the training instability we observed when the key and value vectors were trainable. The MMLU score dips to below 30\% before recovering. (\textbf{Left}) The y-axis is accuracy on questions from \longhealth.}
    \label{fig:freeze}
\end{figure*}


% Content from: figures/initialization/initialization.tex

\begin{figure*}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/initialization/initialization-fig.pdf}
    \caption{\textbf{Ablating \artifact initalization}. We train a \artifacts using \method on the corpora from \longhealth with 3 different initialization strategies. The $x$ axis is the number of training steps and the $y$ axis is the  accuracy on \longhealth. The blue lines are the results when initializing the \artifact using the KV cache from the first $k$ tokens of the document. The purple lines are initializing the \artifact from the KV cache of unrelated text. The green lines is initializing the \artifact with random vectors. Initializing from the first $k$ tokens leads to slightly stronger results than initializing from the KV cache of random text. This difference may be more prominent on other corpora where the first $k$ tokens are more relevant to solving the downstream task.}
    \label{fig:intialization}
\end{figure*}


% Content from: figures/logits/logits.tex

\begin{figure*}[ht]
    \centering
    \includegraphics[width=\textwidth]{figures/logits/logits-fig.pdf}
    \caption{\textbf{Context-distillation objective improves training efficiency}. We train \artifacts using \method on the corpora from \longhealth (Left), \mtob (Center) and \qasper (Right) using two loss functions: a next token prediction loss (green) and a distillation loss (blue).
        We evaluate the performance of the \artifacts on questions from the target dataset (\longhealth, \mtob or \qasper) using the same protocol as in \Cref{fig:scaling-indexing}. In all plots, the $x$ axis is the number of training steps, and the $y$ axis is either accuracy (for \longhealth and \mtob) or perplexity on ground truth answer (for \qasper).
         The shade of the points represents the size of the \artifact. Using a distillation loss achieves higher accuracy (or lower perplexity for \qasper) across datasets and \artifact sizes.}
    \label{fig:logits}
\end{figure*}


% Content from: figures/micros/micros.tex

\begin{figure*}[t!]
    \centering
    \includegraphics[width=\textwidth]{figures/micros/plot.pdf}
    \caption{
        \textbf{\artifacts trained with \method balance the generality and memory consumption tradeoff.}
        We compare four methods on the \genconvo dataset: \artifacts trained with next-token prediction over $\ctx$, \artifacts trained with \method, full ICL, and truncated ICL, a prompt compression method in which we truncate the $\ctx$ to the first $k$ tokens.
        (\textbf{Left}) We evaluate on different slices from the \genconvo dataset. \artifacts trained with next-token prediction performs well on memorization queries, which resemble it's training distribution, but cannot generalize to other queries like the other methods.
        (\textbf{Center}) The $x$-axis measures the size of the KV cache in GB for the different methods.
        The $y$-axis shows log-perplexity on the \genconvo dataset averaged over the query types.
        (\textbf{Right}) Peak throughput (tokens/s) measured for different cache sizes for \llamathreeb and \llamaeightb with SGLang~\cite{zheng2024sglang} on an 1xH100 (See \Cref{app:results}).
    }
    \label{fig:micros}
\end{figure*}


% Content from: figures/parameterization/parameterization.tex

\begin{figure*}[htbp]
    \centering
    \includegraphics[width=\textwidth]{figures/parameterization/parameterization-fig.pdf}
    \caption{
        \textbf{Comparing \artifact parameterizations.}
        We train \artifacts using \method on the corpora from \longhealth (Top), \qasper (Middle), and \mtob (Bottom) using two different parameterizations: simplified prefix-tuning (as described in \Cref{sec:artifact-parameterization}) and low-rank adaptation (LoRA)~\cite{hu2022lora}.
        We experiment with different \artifact sizes and choose LoRA rank and prefix-tuning cache size to align on memory consumption.
        We evaluate the performance of the \artifacts on questions from the target dataset (\longhealth or \qasper) using the same protocol as in \Cref{fig:tradeoff-within} and also on questions from MMLU~\cite{hendrycks2020measuring} that are unrelated to the corpora.
        (\textbf{Left}) The $x$-axis shows accuracy on MMLU and the $y$-axis shows accuracy on the target dataset. Each point represents a different \artifact size.
        (\textbf{Center}) The $x$-axis shows \artifact size in GB, and the $y$-axis shows accuracy on MMLU.
        (\textbf{Right}) The $x$-axis shows self-study duration in training steps, and the $y$-axis shows accuracy on MMLU. The shade of the points represents the size of the \artifact.
        }
    \label{fig:parameterization}
    \vspace{-2mm}
\end{figure*}


% Content from: figures/scaling-indexing/scaling-indexing.tex

\begin{figure*}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/scaling-indexing/scaling-indexing-fig.pdf}
    \caption{\textbf{Scaling \method compute.} These plots show how quality improves as we scale the training compute with \method.
        In all plots, the $x$-axis shows the total number of global training steps with batch size 64 and maximum sequence length 1024.
        No synthetically generated data is reused (\ie training proceeds for one epoch).
        Curves are provided for \artifacts of varying sizes ($p \in \{128, 512, 2048, 8192\}$).
        (\textbf{Left}) The $y$-axis shows accuracy on \longhealth~\cite{adams2024longhealth} with \llamaeightb.
        (\textbf{Middle}) The $y$-axis shows the chrF on \mtob~\cite{tanzer2023benchmark} with \llamathreeb.
        (\textbf{Right}) The $y$-axis shows log-perplexity (lower is better) on \qasper~\cite{dasigi2021dataset} with \llamathreeb.
    }
    \label{fig:scaling-indexing}
\end{figure*}


% Content from: figures/seeds/seeds.tex

\begin{figure*}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/seeds/seeds-fig.pdf}
    \caption{\textbf{Diverse seed prompts improve quality.}
    We generate synthetic data according to \Cref{alg:synthetic-generation} and ablate the choice of seed prompts sampled on Line 2.
    We consider two approaches: using a single, broad seed prompt (Green) or randomly sampling one of five different types of seed prompts (Blue).
    We train \artifacts using self-study with these two strategies on \longhealth, \mtob and \qasper corpora.
    In all plots, the $x$ axis is the number of training steps, and the $y$ axis is either accuracy (for \longhealth and \mtob) or perplexity on ground truth answer (for \qasper).
    We use an \artifact size of 1024 tokens.
         }
    \label{fig:seeds}
\end{figure*}


% Content from: figures/tradeoff-within/tradeoff-within.tex

\begin{figure*}[t!]
    \centering
    \includegraphics[width=\textwidth]{figures/tradeoff-within/tradeoff-within-fig.pdf}
    \caption{
        \artifacts \textbf{matches ICL quality with lower memory costs.}
        We measure \llamathreeb response quality ($y$-axis) against KV cache memory ($x$-axis) for different methods, at different KV cache sizes. The dashed line marks the quality of standard ICL.
        }
    \label{fig:tradeoff-within}
    \vspace{-2mm}
\end{figure*}


% Content from: macros.tex

\newcommand{\yell}[1]{\textcolor{red}{#1}}
\newcommand{\todo}[1]{TODO: \textcolor{blue}{#1}}
\newcommand{\method}{\textsc{Self-Study}\xspace}
\newcommand{\methodplus}{\textsc{Cartridge++}\xspace}
\newcommand{\artifact}{\textsc{Cartridge}\xspace}
\newcommand{\artifacts}{\textsc{Cartridges}\xspace}
\newcommand{\problem}{multi-query indexing\xspace}
\newcommand{\Problem}{Multi-query indexing\xspace}
\newcommand{\longhealth}{\textsc{LongHealth}\xspace}
\newcommand{\longhealthhalf}{\textsc{LongHealth Half}\xspace}
\newcommand{\longhealthfull}{\textsc{LongHealth Full}\xspace}
\newcommand{\reglabhousing}{\textsc{RegLab Housing QA}\xspace}
\newcommand{\mtob}{\textsc{MTOB}\xspace}
\newcommand{\qasper}{\textsc{QASPER}\xspace}
\newcommand{\mrcr}{\textsc{MRCR}\xspace}
\newcommand{\genconvo}{\textsc{GenConvo}\xspace}
\newcommand{\llama}{\textsc{Llama}\xspace}
\newcommand{\llamathree}{\textsc{Llama 3}\xspace}
\newcommand{\llamathreeb}{\textsc{Llama-3B}\xspace}
\newcommand{\llamaeightb}{\textsc{Llama-8B}\xspace}
\newcommand{\llamaseventyb}{\textsc{Llama-70B}\xspace}
\newcommand{\llamaoneb}{\textsc{Llama-1B}\xspace}
\newcommand{\eg}{\textit{e.g.}\xspace}
\newcommand{\ie}{\textit{i.e.}\xspace}
\newcommand{\etc}{\textit{etc.}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\ctx}{\mathcal{C}}
\newcommand{\subctx}{\tilde{\mathbf{c}}}
\newcommand{\seed}{\mathbf{s}}
\newcommand{\ctxrep}{Z}
\newcommand{\ctxrepkv}{Z_\text{KV}}
\newcommand{\model}{\mathcal{M}}
\newcommand{\queries}{Q}
\newcommand{\query}{q}
\newcommand{\resps}{R}
\newcommand{\resp}{r}
\newcommand{\vocab}{\mathcal{V}}
\newcommand{\llm}{\mathcal{F}}
\newcommand{\numtrain}{m_\text{train}}
\newcommand{\seqlength}{n}
\newcommand{\seqlengthsub}{n_\text{sub}}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{observation}{Observation}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{proposition}{Proposition}
\newtheorem{assumption}{Assumption}
\newtcolorbox{examplebox}[1][]{
    colback=lightgray!10,
    colframe=black,
    boxrule=0.75pt,
    title=#1,
    fonttitle=\bfseries,
    left=3pt,
    right=3pt,
    top=2pt,
    bottom=2pt,
    breakable,
}
\newtcolorbox{exampleboxcode}[1][]{
    colback=lightgray!10,
    colframe=blue,
    boxrule=0.75pt,
    title=#1,
    fonttitle=\ttfamily,
    left=3pt,
    right=3pt,
    top=2pt,
    bottom=2pt,
}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}
\lstdefinestyle{codestyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    xleftmargin=10pt,
    xrightmargin=10pt
}
\lstset{style=codestyle}
\newcommand{\repetitiveMQAR}{\text{repetitive MQAR}}
\newcommand{\numKeys}{s}
\newcommand{\contextSize}{N}
\newcommand{\numPairs}{m}
\newcommand{\numQueries}{n}
\newcommand{\timestep}{t}
\newcommand{\emptyToken}{\text{NULL}}
\newcommand{\modelDim}{d}
\newcommand{\wKey}{\mW_{\text{key}}}
\newcommand{\wVal}{\mW_{\text{val}}}
\newcommand{\wQry}{\mW_{\text{qry}}}
\newcommand{\state}{\mW}
\newcommand{\stateTime}[1]{\mS^{(#1)}}
\newcommand{\stateTimeT}[1]{\left(\mS^{(#1)}\right)^{\top}}
\newcommand{\cacheMatrix}{\mW}
\newcommand{\cacheMatrixTime}[1]{\cacheMatrix^{(#1)}}
\newcommand{\kvSet}{S}
\newcommand{\kvpair}[1]{(\key{#1}, \val{#1})}
\newcommand{\key}[1]{\vk^{(#1)}}
\newcommand{\keyT}[1]{\left(\vk^{(#1)}\right)^\top}
\newcommand{\val}[1]{\vv^{(#1)}}
\newcommand{\valT}[1]{\left(\vv^{(#1)}\right)^\top}
\newcommand{\error}[2]{\eps_{#1,#2}}
\newcommand{\errs}[3]{C_{#1,#2}^{(#3)}}
\newcommand{\maxEps}{\overline{\eps}}
\newcommand{\epsPow}{x}
\newcommand{\totalError}{\eps_{total}}
\newcommand{\numReps}{q}


% Content from: main.tex

\documentclass{article}
\def\conference{arxiv}
\def\neuripsconf{neurips}
\def\icmlconf{icml}
\def\arxivconf{arxiv}
\usepackage[table,xcdraw]{xcolor}
\ifx\conference\neuripsconf
    \usepackage[nonatbib]{styles/neurips_2025}
    \usepackage[numbers,sort&compress]{natbib}
\else\ifx\conference\arxivconf
    \usepackage{styles/arxiv}
\else
    \usepackage{styles/icml2025}
\fi
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{nicefrac}
\usepackage{microtype}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage[breakable]{tcolorbox}
\usepackage{listings}
\usepackage{bbold}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{ifthen}
\usepackage{fontawesome5}
\usepackage{amsthm}
\usepackage{math_commands}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\input{macros.tex}
\makeatletter
\newcommand{\github}[1]{
   \href{#1}{\faGithubSquare}
}
\makeatother
\ifx\conference\neuripsconf
\title{\artifacts: Lightweight and general-purpose long context representations via self-study}
\author{
  David S.~Hippocampus\thanks{Use footnote for providing further information
    about author (webpage, alternative address)---\emph{not} for acknowledging
    funding agencies.} \\
  Department of Computer Science\\
  Cranberry-Lemon University\\
  Pittsburgh, PA 15213 \\
  \texttt{hippo@cs.cranberry-lemon.edu} \\
}
\begin{document}
\maketitle
\else\ifx\conference\icmlconf
\icmltitlerunning{Submission and Formatting Instructions for ICML 2025}
\begin{document}
\twocolumn[
\icmltitle{\artifacts: Lightweight and general-purpose long context representations via self-study}
\icmlsetsymbol{equal}{*}
\begin{icmlauthorlist}
\icmlauthor{Firstname1 Lastname1}{equal,yyy}
\icmlauthor{Firstname2 Lastname2}{equal,yyy,comp}
\icmlauthor{Firstname3 Lastname3}{comp}
\icmlauthor{Firstname4 Lastname4}{sch}
\icmlauthor{Firstname5 Lastname5}{yyy}
\icmlauthor{Firstname6 Lastname6}{sch,yyy,comp}
\icmlauthor{Firstname7 Lastname7}{comp}
\icmlauthor{Firstname8 Lastname8}{sch}
\icmlauthor{Firstname8 Lastname8}{yyy,comp}
\end{icmlauthorlist}
\icmlaffiliation{yyy}{Department of XXX, University of YYY, Location, Country}
\icmlaffiliation{comp}{Company Name, Location, Country}
\icmlaffiliation{sch}{School of ZZZ, Institute of WWW, Location, Country}
\icmlcorrespondingauthor{Firstname1 Lastname1}{first1.last1@xxx.edu}
\icmlcorrespondingauthor{Firstname2 Lastname2}{first2.last2@www.uk}
\icmlkeywords{Machine Learning, ICML}
\else\ifx\conference\arxivconf
\title{Cartridges: Lightweight and general-purpose long context \\ representations via self-study}
\author{\textbf{Sabri Eyuboglu} \textsuperscript{1}$^*$
\quad
\textbf{Ryan Ehrlich} \textsuperscript{1}$^*$
\quad
\textbf{Simran Arora} \textsuperscript{1,2}$^* $
\quad
\textbf{Neel Guha} \textsuperscript{1}
\quad
\textbf{Dylan Zinsley} \textsuperscript{3}
\quad
\textbf{Emily Liu} \textsuperscript{1} \\
\textbf{Will Tennien}  \textsuperscript{1}
\quad
\textbf{Atri Rudra} \textsuperscript{3}
\quad
\textbf{James Zou} \textsuperscript{1}
\quad
\textbf{Azalia Mirhoseini} \textsuperscript{1}
\quad
\textbf{Christopher Ré} \textsuperscript{1} \\[5pt]
\textsuperscript{1}Stanford University \quad \textsuperscript{2} Caltech \quad \textsuperscript{3}University at Buffalo \quad \quad * Equal contribution \\[3pt]
\faEnvelope \enspace \texttt{eyuboglu@stanford.edu, rehrlich@stanford.edu, simarora@stanford.edu} \\
\faGithubSquare \enspace \texttt{\href{https://github.com/HazyResearch/cartridges}{HazyResearch/cartridges}}
}
\begin{document}
\maketitle
\fi
\begin{abstract}
Large language models are often used to answer queries grounded in large text corpora (\eg codebases, legal documents, or chat histories) by placing the entire corpus in the context window and leveraging in-context learning (ICL).
Although current models support contexts of 100K–1M tokens, this setup is costly to serve because the memory consumption of the KV cache scales with input length.
We explore an alternative: training a smaller KV cache offline on each corpus.
At inference time, we load this trained KV-cache, which we call a \artifact, and decode a response. Critically, the cost of training a \artifact can be amortized across all the queries referencing the same corpus.
However, we find that the naive approach of training the \artifact with next-token prediction on the corpus is not competitive with ICL.
Instead, we propose \method, a training recipe in which we generate synthetic conversations about the corpus and train the \artifact with a context-distillation objective.
We find that \artifacts trained with \method replicate the functionality of ICL, while being significantly cheaper to serve.
On challenging long-context benchmarks, \artifacts trained with \method match ICL performance while using $38.6\times$ less memory and enabling $26.4\times$ higher throughput. \method also extends the model’s effective context length (\eg from 128k to 484k tokens on MTOB) and surprisingly, leads to \artifacts that can be composed at inference time without retraining.
\end{abstract}
\input{sections/01_introduction.tex}
\input{sections/02_related_work}
\input{sections/03_cartridges}
\input{sections/04_method.tex}
\input{sections/05_results.tex}
\input{sections/acks.tex}
\ifx\conference\neuripsconf
    \bibliographystyle{plain}
\else\ifx\conference\icmlconf
    \bibliographystyle{icml2025}
\else\ifx\conference\arxivconf
    \bibliographystyle{plain}
\fi
\fi
\bibliography{references}
\clearpage
\appendix
\input{sections/appendix/extended-results}
\input{sections/appendix/extended-related-work}
\input{sections/appendix/extended-methods}
\input{sections/appendix/extended-experiments}
\input{sections/appendix/repetitive-mqar}
\end{document}


% Content from: sections/01_introduction.tex

\vspace{-2mm}
\section{Introduction}
Large language model (LLM) users often place large text corpora into the context window. For instance, a user or organization may use LLMs to understand codebases~\cite{nam2024using}, financial documents~\cite{islam2023financebench}, legal texts~\cite{guha2023legalbench, zheng2025reasoning}, textbooks~\cite{ouellette2025can}, or personal files~\cite{arora2022can}.
LLMs excel here due to in-context learning (ICL), enabling accurate responses to diverse queries (e.g., factual Q\&A, summarization, code generation)~\cite{dong2022survey}.
Despite its flexibility, this usage paradigm is costly to serve. ICL requires maintaining a KV cache that grows linearly with the input length. For example, LLaMA 70B needs 84 GB of memory (at 16-bit precision) to answer a single question over a 128k-token context~\cite{dubey2024llama3}. This severely limits user throughput: on a single H100 GPU, LLaMA 8B’s peak throughput (tokens/s) drops by $77\times$ when increasing the context from 1k to 120k tokens (\Cref{fig:micros}).
Prior work has thus explored ways to reduce KV cache memory usage. For instance, prompt compression methods reduce the number of tokens stored in the cache using summarization, or self-information filtering~\cite{jiang2023llmlingua,li2023unlocking,chuang2024learning}, while KV cache compression techniques directly compress the stored key-value pairs~\cite{ge2023model,zhang2023h2o,tang2024quest,oren2024transformers}. Unfortunately, there are memory-quality tradeoffs associated with these methods: in experiments on challenging long-context tasks, we find that performance  degrades rapidly when applying these methods with compression ratios greater than $2\times$ (see \Cref{fig:tradeoff-within}).
Motivated by the observation that the cost of preparing a KV cache can be amortized across many queries that reference the same corpus, we explore a complementary approach based on offline training. Given a specific text corpus (\eg a patient's medical record) we freeze the LLM and train a smaller KV cache offline by backpropagating loss into the key and value vectors in a process essentially equivalent to prefix tuning~\cite{li2021prefix,lester2021power}. We call the trained KV cache representing the corpus  a ``\artifact.'' At inference time, we load the trained \artifact, append the user’s messages, and decode. Because users repeatedly reference the same corpora  (\eg SEC filings, codebase, personal files), each \artifact can be trained once offline and reused. This approach also integrates cleanly with existing inference servers, which are already designed to manage per-user KV caches~\cite{kwon2023efficient,zheng2024sglang,juravsky2025tokasaurus,ye2025flashinfer}.
\input{figures/banner/banner}
Achieving ICL-equivalent functionality requires \artifacts to satisfy two non-trivial desiderata. First, \artifacts should replicate the generality of ICL, and provide accurate responses across diverse user prompts~\cite{dong2022survey}.
Second, \artifacts should replicate ICL's  structural awareness---its ability to reason over document structure, and understand how distant parts of a corpus relate or depend on each other (an ability that degrades when using lossy KV-cache compression methods).
It is unclear if there is a procedure that satisfies these desiderata, while providing memory efficiency.
The natural baseline approach is to train a \artifact with a next-token prediction objective on the raw corpus. Excitingly, this yields \artifacts that memorize the corpus \textit{perfectly} using $107\times$ less memory than the KV-cache. However, the resulting \artifacts are not general - they degrade the LM's ability to respond to diverse questions beyond regurgitating the corpus (\Cref{fig:micros}).
To address these challenges and produce general, structurally aware \artifacts for any text corpus, we propose an automated method called \method. \method has two steps:
\begin{enumerate}[leftmargin=*]
    \item \textbf{Synthetic data generation} (\Cref{sec:method-data}): We generate synthetic training data by prompting the model to quiz itself about the corpus content, resulting in a synthetic conversation trace. Training on these lets us avoid training on the same exact text multiple times and improves generality (see \Cref{fig:micros}).
To support corpora that exceed the effective context length of the model, we chunk the corpus when generating synthetic conversations.
We also curate a set of seed prompts that bias the synthetic conversations towards global reasoning and improve structural awareness (see \Cref{fig:ablations} right).
    \item \textbf{Context distillation} (\Cref{sec:method-objective}): We train on the synthetic conversations using a context-distillation objective~\cite{bhargava2024prompt,snell2022learning}, which aligns the \artifact-augmented model's next-token distributions with the distributions of the model with the corpus in context. We find that the context distillation substantially improves the quality of the \artifacts compared to next-token-prediction (see \Cref{fig:ablations} center).
\end{enumerate}
In summary, given a large corpus of text, our goal is to train a small virtual KV cache, termed \artifact, that when used by the model, mimics the conversational behavior of the model with the entire corpus in context. To do this, we generate synthetic conversations and train the \artifact on them with a context distillation objective --- a recipe we call \method.
\textbf{Evaluations.} We evaluate \artifacts trained with {\method} on a set of challenging benchmarks that pair a single large text corpus ($100$k-$484$k tokens) with a diverse set of queries~\cite{islam2023financebench,adams2024longhealth,tanzer2023benchmark}.
We make three claims. \textbf{First}, \artifacts extends the quality-memory frontier---averaged across the benchmarks, \artifacts produced with \method match ICL quality while consuming $38.6\times$ less memory, enabling a $26.4\times$ increase in peak throughput (tokens per second) when serving many users with different corpora. These memory reductions and speedups represent an order of magnitude improvement over state-of-the-art cache compression baselines (\eg DuoAttention~\cite{xiao2024duoattention}). \textbf{Second}, \artifacts enables context length extrapolation. On the MTOB benchmark~\cite{tanzer2023benchmark}, where models must translate from Kalamang, a low-resource language, into English, we use \method with \llamaeightb to construct a small \artifact from a $484$k token textbook.
This \artifact outperforms ICL over the first $130,000$ tokens of the textbook by $11.0$ chrF points and matches the ICL performance over a curated subset of the textbook.
\textbf{Third}, \method also yields \artifacts that are composable without joint optimization: multiple \artifacts can be concatenated and queried together, emulating ICL's ability to flexibly answer queries over multiple documents concatenated in context (see \Cref{fig:composition}).
Additionally, we carefully ablate the design decisions in \method and \artifacts (\Cref{sec:results-ablations} and \Cref{app:results}). Notably, we compare \artifacts parameterized as a KV cache~\cite{li2021prefix} with \artifacts parameterized as a LoRA \cite{hu2022lora} and find that KV cache parameterization performs better on both in-domain and out-of-domain tasks.
In this work, we demonstrate how offline KV cache training can dramatically reduce the cost of serving language models in settings where users repeatedly include the same text corpora in context.
We hope that these cost reductions could enable new applications that are currently intractable, like coding agents with full-repository context or long-term memory in chatbots.


% Content from: sections/02_related_work.tex

\vspace{-2mm}
\section{Preliminaries}
\input{figures/comparison/comparison_table}
We begin by discussing related work (\Cref{sec:related_work}), formalizing our problem (\Cref{sec:problem-setup}), and providing background on language models and KV caches (\Cref{sec:lm-background}).
\label{sec:preliminaries}
\subsection{Related work}\label{sec:related_work}
\ifx\conference\icmlconf
\input{figures/micros/micros}
\fi
\textit{See Appendix \ref{app:related-work} for a detailed discussion of prior work.}
\vspace{-1mm}
\paragraph{Parameter Efficient Fine-Tuning and Knowledge Injection}
In order to adapt a language model to a specific task or domain, practitioners commonly train a small number of parameters, which augment or modify the original model~\cite{hu2022lora,li2021prefix,lester2021power, meng2024pissa,zaken2021bitfit}.
In particular, low rank adaptation~\cite{hu2022lora}, where linear layers are adapted with low rank updates, is the de facto parameter efficient fine-tuning technique.
In our work, we build upon a less popular technique, prefix-tuning~\cite{li2021prefix,lester2021power}, where we optimize internal activations for a set of ``virtual'' tokens preceding the input.
Recent works on \textit{knowledge injection} apply LoRA (or variants~\cite{mao2025lift}) to store a text corpus in a small number of parameters~\cite{zhang2023plug,xiao2023plug,kujanpaa2024knowledge,mao2025lift,su2025parametricrag}.
This allows models to answer queries using parameteric knowledge as opposed to ICL.
The earliest methods in this line of work inject knowledge with next-token prediction objectives on the corpus~\cite{zhang2023plug,xiao2023plug,kuratov2025cramming}.
Excitingly, recent and concurrent work has also demonstrated the power of synthetic data~\cite{mao2025lift,su2025parametricrag} and context-distillation objectives~\cite{kujanpaa2024knowledge,caccia2025training} in knowledge injection.
In contrast to our work, these papers do not focus on memory reductions or throughput improvements enabled by knowledge injection.
Furthermore, they do not use a prefix-tuning parameterization, formulate synthetic data generation as a conversation, or seed the conversation with diverse seed prompts, which we find to be critical for performance on long-context tasks and out-of-domain generalization.
Related to our analysis of \artifact composition are a number of works that compose multiple different parameter-efficient adapters through various aggregation operations ~\cite{zhao2024merging,huang2023lorahub,xiao2024configurable,zhao2024loraretriever,yadav2024survey,wu2024mixture,gou2023mixture,li2024mixlora}.
\vspace{-1mm}
\paragraph{Prompt and KV-cache compression} Because the size of the KV cache is a major determinant of language model serving cost, many works have proposed techniques to reduce the size of the cache. One set of approaches focus on making the prompt smaller---explicit methods alter the prompt text through summarization and filtering ~\cite{jiang2023llmlingua,li2023unlocking,chuang2024learning,zhang2024adacomp,pan2024llmlingua}, while implicit methods compress prompt representations into a set of ``soft'' tokens~\cite{chevalier2023adapting,yen2024long,ge2023context,mu2023learning,qin2023dodo, lester2021power}. Another set of approaches exploits observations about the structure of the KV cache~\cite{yu2024effectively,chang2024palu,kim2024lexico}, often finding that because a small number of keys dominate the attention scores of subsequent queries, non-impactful key-value pairs (or tokens) can be dropped~\cite{ge2023model,zhang2023h2o,tang2024quest,oren2024transformers, li2024snapkv} or merged~\cite{wang2024model,zhang2024cam,wan2024d2o}.
Compared with our work, these methods use relatively little compute to compress the KV cache. We focus on the setting where scaling the amount of compute used to compress the KV cache makes sense because contexts are shared across many requests.
\vspace{-1mm}
\paragraph{Architectural changes} A large body of work has studied architectural changes to the original multi-head attention operation~\cite{vaswani2017attention} with the aim of reducing the memory footprint of the KV cache or replacing it with a memory object of constant size.
Unlike \method and the compression approaches discussed above, which can be readily applied to any pre-trained Transformer, these architectural changes typically require retraining the model from scratch or using complex architecture conversion techniques~\cite{zhang2024lolcats}.
In order to reduce the memory footprint of the KV cache, these architectures leverage sparsity ~\cite{beltagy2020longformer,child2019generating,zaheer2020big, team2024gemma}, reduce the number of key and value heads~\cite{shazeer2019fast, ainslie2023gqa}, make the key and value heads low-rank~\cite{liu2024deepseek}, or replace the KV cache with a constant-size memory object~\cite{ zhang2025tensor, arora2024simple,gu2023mamba,yang2024fla,yang2024gla}.
In particular, grouped-query attention~\cite{ainslie2023gqa} is the de-facto multi-head attention variant, used in frontier language models like Llama 3~\cite{dubey2024llama3}. In our experiments, we compare against ICL with grouped-query attention.
Other variants --- such as multi-head latent attention~\cite{liu2024deepseek} or linear attention~\cite{arora2024simple,gu2023mamba} --- are gaining popularity and feature in large-scale reasoning models~\cite{guo2025deepseek} and hybrid models~\cite{li2025minimax,blakeman2025nemotron,team2024jamba}.
Most related to our work are recent architectures (\eg Titans~\cite{behrouz2024titans}, TTT~\cite{sun2024learning}) that use a constant-sized memory object (like in linear attention) but apply gradient descent-like memory updates~\cite{sun2024learning,yang2025parallelizinglineartransformersdelta,behrouz2025atlas,behrouz2024titans,behrouz2025s}.
Like our work, these architectures are motivated by the observation that gradient descent is very effective at compressing text into constant space and demonstrate the promise of using gradient descent at test time for long-context tasks.
In contrast with our work, these architectures need to be trained from scratch, they have not been validated on large scale models, and do not match the quality of attention on recall-intensive tasks~\cite{arora2024simple,behrouz2025atlas}.
\ifx\conference\arxivconf
\input{figures/micros/micros}
\fi


% Content from: sections/03_cartridges.tex

\vspace{-2mm}
\vspace{-1mm}
\subsection{Problem setup}\label{sec:problem-setup}
We assume a setting in which users issue a stream of diverse queries about a common corpus of text. We denote the corpus as $\ctx$ and the query set as $\queries = \{\query_1, \query_2,\hdots,\query_m\}$. Illustrative examples of $\ctx$ include legal filings, financial documents, code repositories, chat histories, and medical records.
\begin{examplebox}[Example: Financial Analysis]
    $\ctx$ may correspond to the 2022 Form 10-K filing~\cite{sec_read10k} for AMD, which is almost 100k tokens. The queries an analyst might ask an LLM to answer with respect to this form are diverse, including: (1) recalling factual information, (2) performing mathematical reasoning over values, or (3) even generating creative responses (e.g., a poem) grounded in the 10-K's information.
\end{examplebox}
Let $\resps = \{\resp_1, \resp_2,\hdots,\resp_m\}$ denote the responses the LLM produces for the queries. We have two objectives. First, we wish to maximize the quality of responses $\resps$ under some quality metric (\eg accuracy). Second, we wish to minimize the LLM's memory footprint while it is answering questions with respect to the document. This is because larger memory footprints decrease throughput and necessitate more hardware to serve the same number of users (\Cref{fig:micros}, Right).
\vspace{-2mm}
\subsection{Language models and KV caches}
\label{sec:lm-background}
Recall that an LLM $\llm$ accepts as input a sequence of $N$ tokens $\mathbf{x} \in \mathcal{V}^n$  drawn from a discrete vocabulary $\vocab \subset \mathbb{Z}$ of tokens, each represented by a unique integer.
The output, which we denote $\llm(\cdot | \mathbf{x})$, corresponds to a categorical distribution over a vocab $\vocab$ conditioned on the prefix  $\mathbf{x} \in \vocab^n$.
Inside the language model, each token $x[i]$ in $\mathbf{x}$ is embedded into a $d$-dimensional space, yielding a matrix $\mathbf{u} \in \mathbb{R}^{n\times d}$.
The matrix $\mathbf{u}$ is passed through a stack of $L$ model layers, which each mix the matrix along the $n$ and $d$ dimensions, with layer $\ell$ outputting $\mathbf{y}^l \in \mathbb{R}^{n\times d}$.
The final $\mathbf{y}^L$ is mapped to the logits over $\vocab$ with a linear projection.
Most modern language models use the Transformer architecture based on self-attention~\cite{vaswani2017attention}. Given an input $\mathbf{u} \in \mathbb{R}^{n\times d}$ for sequence length $n$ and embedding dimension $d$, it computes the output $\mathbf{y}^l \in \mathbb{R}^{n \times d}$ via the softmax over projections
\(
\mathbf{q}, \mathbf{k}, \mathbf{v} = \mathbf{u} \mathbf{W}_q, \mathbf{u} \mathbf{W}_k, \mathbf{u} \mathbf{W}_v
\):
\begin{equation}
\mathbf{y}[i] = \sum_{j=1}^i\frac{\exp(\mathbf{q}[i]^\top \mathbf{k}[j] /\sqrt{d}) \mathbf{v}[j] }{\sum_{t = 1}^{i} \exp(\mathbf{q}[i]^\top \mathbf{k}[t] /\sqrt{d})}
\label{eq:softmax_attention}
\end{equation}
where weight matrices $\mW_q$, $\mW_k$ and $\mW_v$ for each layer are learned during training.
When generating from $\llm$, we generate one token at a time by sampling from $\llm(\cdot \mid \mathbf{x})$ and appending the sampled token to $\mathbf{x}$.
Critically, the attention operator is causal: every output $\mathbf{y}[i]$ is conditioned on prior tokens.
This allows us to avoid recomputing the keys and values for the prior tokens by storing them in a KV cache $\{\mathbf{k}[j], \mathbf{v}[j]\}_{j=1}^{i}$, which grows in $i$.
Thus, generation proceeds in two phases: (1) \textit{prefill}, where we compute the KV cache for the initial prompt $\mathbf{x}$ and (2) \textit{decode}, where we generate the response token by token and append to the KV cache.
After prefill, if $\mathbf{x}$ consists primarily of the corpus $\ctx$, the KV cache effectively serves as a representation of the corpus $\ctx$.
This is why including a long corpus $\ctx$ in the context $\mathbf{x}$ produces large memory footprints, as the size of the KV cache scales linearly in the length of $\mathbf{x}$.
\section{The \artifact paradigm}
\label{sec:artifact}
In this section, we describe the \artifact paradigm, in which we generate representations of the corpus $\ctx$ offline with training, instead of the standard approach of constructing them on-the-fly with prefill.
\vspace{-2mm}
\subsection{Formalizing \artifacts}\label{sec:desiderata}
\label{sec:artifact-desiderata}
Our goal is to train a \artifact for a given corpus $\ctx$. A \artifact is a small set of parameters $\ctxrep \in \mathbb{R}^*$ (\ie an adapter~\cite{li2021prefix,hu2022lora}) that augments an LLM $\llm$ and causes it to behave as if it had $\ctx$ in its context window. Formally, let $\llm_Z( \cdot | \query )$ denote the distribution of $\llm$ augmented with $Z$ given a query $\query$. For all $\query \in \queries$, we want to ensure that samples $r_Z \sim \llm_Z(\cdot | \query)$ are as good or better than the ICL sample $r_q \sim \llm(\cdot | \ctx \oplus \query)$, according to some query-specific scoring function. In order for $\llm_Z(\cdot | \query)$ to match or exceed the behavior of $\llm(\cdot | \ctx \oplus \query)$, three important criteria should be met.
\begin{itemize}[leftmargin=*]
    \item \textbf{Displays generality}: Because $\queries$ might span a diverse range of question types (e.g., mathematical reasoning, factual recall comprehension, summarization, and more), it is essential that $\llm_Z$ can generalize across different $\query \in \queries$. \textbf{This is non-trivial because $\queries$ is unknown when $Z$ is being learned offline.} If $\llm_Z$ does not generalize, then practitioners may need to learn different $Z$ for different distributions of queries, which increases the cost of the \artifact. Ideally, $Z$ should only need to be learned once, yet work for multiple types of queries.
    \item \textbf{Captures long range dependencies}: $Z$ should also capture long range dependencies contained within $\ctx$. In many settings, correctly answering different $\query \in \queries$ requires reasoning about the order of information presented in $\ctx$. It is not clear how to capture these dependencies in $Z$.
    \item \textbf{Capable of composition}: Ideally, the representation of $Z$ and mechanism by which $\llm$ utilizes it could allow for composition, without any particular joint training of \artifacts. Given $Z_1$ and $Z_2$ corresponding to $\ctx_1$ and $\ctx_2$, ideally $\llm_{[Z_1, Z_2]}(\query)$ is similar to $\llm(\cdot | \ctx_1 \oplus \ctx_2 \oplus \query])$
\end{itemize}
\vspace{-2mm}
\subsection{Parameterizing \artifacts}\label{sec:representing_cartridge}
\label{sec:artifact-parameterization}
We parameterize $\ctxrep$ using a simplified version of prefix-tuning~\cite{li2021prefix}.
Specifically, we allocate a KV cache composed of \textit{trainable} key and value vectors $\mathbf{z}_\text{k}, \mathbf{z}_\text{v} \in \mathbb{R}^{p \times d}$.
The size of the full $Z\in \mathbb{R}^{L \times p \times d \times 2}$ is controlled by the hyperparameter $p$.
The memory footprint of $Z$ is equivalent to a KV cache for a prompt with $p$ tokens.
In ICL, the KV cache for $\llm_\ctx(q)$ (where $\ctx$ is of length $n_\ctx$ and $\queries$ is of length $n_\queries$) would contain $n_\ctx + n_\queries$ key-value pairs, with the first $n_\ctx$ corresponding to $\ctx$ and the last $n_\queries$ corresponding to $\queries$:
\ifx\conference\neuripsconf
\[
\begin{minipage}{0.50\textwidth}
\centering
\text{ICL KV Cache} \vspace{-1.5em} \\
\begin{align*}
\underbrace{(\mathbf{k}_1, \mathbf{v}_1), \dots, (\mathbf{k}_{n_\ctx}, \mathbf{v}_{n_\ctx})}_{\text{KV pairs for~}\ctx},
\underbrace{(\mathbf{k}_{n_\ctx + 1}, \mathbf{v}_{n_\ctx + 1})\dots}_{\text{KV pairs for } \query }
\end{align*}
\end{minipage}
\quad
\begin{minipage}{0.50\textwidth}
\centering
\text{\artifact KV Cache} \vspace{-1.5em} \\
\begin{align*}
\underbrace{(\mathbf{z}^\text{k}_1, \mathbf{z}^\text{v}_1), \dots, (\mathbf{z}^\text{k}_{p}, \mathbf{z}^\text{v}_{p})}_{\text{Trainable KV pairs in }Z},
\underbrace{(\mathbf{k}_{n_\ctx + 1}, \mathbf{v}_{n_\ctx + 1})\dots}_{\text{KV pairs for } \query }
\end{align*}
\end{minipage}
\]
\fi
\ifx\conference\arxivconf
{
\small
\[
\begin{minipage}{0.50\textwidth}
\centering
\text{ICL KV Cache} \vspace{-1.5em} \\
\begin{align*}
\underbrace{(\mathbf{k}[1], \mathbf{v}[1]), \dots, (\mathbf{k}[{n_\ctx}], \mathbf{v}[{n_\ctx}])}_{\text{KV pairs for~}\ctx},
\underbrace{(\mathbf{k}[{n_\ctx + 1}], \mathbf{v}[{n_\ctx + 1}])\dots}_{\text{KV pairs for } \query }
\end{align*}
\end{minipage}
\quad
\begin{minipage}{0.50\textwidth}
\centering
\text{\artifact KV Cache} \vspace{-1.5em} \\
\begin{align*}
\underbrace{(\mathbf{z}_\text{k}[1], \mathbf{z}_\text{v}[1]), \dots, (\mathbf{z}_\text{k}[p], \mathbf{z}_\text{v}[p])}_{ \text{Trainable KV pairs in }Z},
\underbrace{(\mathbf{k}[{1}], \mathbf{v}[{1}])\dots}_{\text{KV pairs for } \query }
\end{align*}
\end{minipage}
\]
}
\fi
\ifx\conference\icmlconf
\text{ICL KV Cache} \vspace{-1.5em} \\
\begin{align*}
\underbrace{(\mathbf{k}_1, \mathbf{v}_1), \dots, (\mathbf{k}_{n_\ctx}, \mathbf{v}_{n_\ctx})}_{\text{KV pairs for~}\ctx},
\underbrace{(\mathbf{k}_{n_\ctx + 1}, \mathbf{v}_{n_\ctx + 1})\dots}_{\text{KV pairs for } \query }
\end{align*}
\text{\artifact KV Cache} \vspace{-1.5em} \\
\begin{align*}
\underbrace{(\mathbf{z}^\text{k}_1, \mathbf{z}^\text{v}_1), \dots, (\mathbf{z}^\text{k}_{p}, \mathbf{z}^\text{v}_{p})}_{\text{Trainable KV pairs in }Z},
\underbrace{(\mathbf{k}_{n_p + 1}, \mathbf{v}_{n_p + 1})\dots}_{\text{KV pairs for } \query }
\end{align*}
\fi
To train a \artifact, we substitute the key-value pairs corresponding to $\ctx$ with $\ctxrep$, and directly optimize them by back-propagating the loss into the key and value vectors.
\textbf{Critically, we freeze all parameters of the model, only training the key and value vectors in $Z$.} We discuss the choice of loss in \Cref{sec:method-objective}.
\vspace{-3mm}
\paragraph{Initialization}
Prior work finds that optimizing a randomly initialized cache $\ctxrep$ is unstable and leads to degraded performance~\cite{li2021prefix}.
Instead, these works initialize the trainable cache with a smaller dimensionality $d$ and then re-project it to the original dimension with an MLP.
In contrast, we find that proper initialization of $\ctxrep$ allows us to directly optimize the full cache without reparametrization.
Specifically, we initialize $\ctxrep$ to the KV cache corresponding to the first $p$ tokens of the corpus $\ctx$.
Alternatively, we could use a summary of the corpus or filter tokens using off-the-shelf prompt compression strategies~\cite{xiao2024duoattention}.
In \Cref{sec:results-ablations}, we show that our initializations lead to stable training and faster convergence than the random initialization.
\textit{Why this parameterization?} We note that the parameter-efficient fine-tuning literature provides other ways to augment an LLM with a set of additional parameters, in particular low-rank adaptation (LoRA)~\cite{li2021prefix,hu2022lora,lester2021power}.
In \Cref{sec:results-ablations}, we perform a comprehensive comparison of \artifacts parameterized with prefix-tuning and LoRA.
\vspace{-2mm}
\subsection{Serving \artifacts}
\label{sec:artifact-serving}
A \artifact can be served efficiently with minimal changes to existing LLM inference servers~\cite{zheng2024sglang,kwon2023efficient,juravsky2025tokasaurus}. Because a \artifact is a KV cache, it can be loaded directly into the KV cache slots using existing mechanisms for handling cached prefixes. LLM inference servers are heavily optimized for managing distinct KV-caches for multiple users~\cite{ye2025flashinfer}, meaning \artifacts can be served at high throughput using existing inference servers. Decoding tokens with a \artifact is identical to serving a request with a prefix of length $p$ (the hyperparameter denoting the number of trainable tokens in the \artifact). This contrasts with other methods like LoRA, which require custom infrastructure to serve efficiently to multiple users~\cite{chen2024punica}. See Figure \ref{fig:micros} for the relationship between prefix length and throughput.


% Content from: sections/04_method.tex

\vspace{-2mm}
\ifx\conference\neuripsconf
\input{figures/micros/micros}
\fi
\section{\method: A self-supervised method for training \artifacts}
\label{sec:method}
In this section, we describe \method, a simple approach for training a \artifact $Z$ on any corpus of text.
The design of \method is motivated by experiments showing how \artifacts trained with a simpler recipe fail to generalize to diverse user queries.
\ifx\conference\arxivconf
\input{figures/tradeoff-within/tradeoff-within}
\fi
\vspace{-2mm}
\paragraph{Motivating observations}
The naive method for constructing a \artifact would be to fine-tune the parameters of $Z$ with the next token prediction objective on the corpus text directly. We show results experimenting with this approach in \Cref{fig:micros}, where we evaluate on a dataset derived from FinanceBench~\cite{islam2023financebench}, which we refer to as \genconvo (see \Cref{app:datasets} for details). \genconvo contains multiple types of questions (\eg synthesis, reasoning).
We find that the naïve next-token prediction approach can memorize with near perfect perplexity (\Cref{fig:micros} left), while consuming $107\times$ less memory than ICL (\Cref{fig:micros} center).
However, generalization to other slices is poor, as shown in \Cref{fig:micros}. We seek a training objective that allows the responses from a model that uses the \artifact to generalize to a diverse set of user queries, resembling ICL.
Motivated by these observations, we describe a synthetic data generation recipe in \Cref{sec:method-data} and a context-distillation objective in \Cref{sec:method-objective}. As we show in \Cref{fig:micros}, \artifacts trained with this approach can generate responses to many types of queries that match the quality of queries generated with ICL.
See \Cref{fig:banner} for a visualization of the \artifact approach.
\ifx\conference\icmlconf
\input{figures/tradeoff-within/tradeoff-within}
\fi
\vspace{-2mm}
\subsection{Self-supervised synthetic data to avoid overfitting}
\label{sec:method-data}
Towards training general \artifacts, we propose using LLM generated synthetic data to generate our training dataset $\mathcal{D}_{\text{train}}$.
\vspace{-2mm}
\paragraph{Overall synthetic data pipeline} Our overall pipeline puts information from the corpus $\ctx$ in context and prompts the model to have a conversation with itself about the corpus to generate the synthetic query-response pairs as shown in \Cref{alg:synthetic-generation}. We represent the concatenation of two vectors with $x \oplus y$.
\input{sections/algorithms/synthetic-data}
The conversation is generated by iteratively sampling generations from two LLM participants $A$ and $B$ (which are the same model). We maintain two different conversation histories: $A$'s starts with a \textit{user} message containing a seed prompt $s$ (\eg \textit{``Please start a conversation by asking a question about the document above."}) followed by alternating \textit{assistant} and \textit{user} messages from $A$ and $B$, respectively. $B$'s conversation history does not include the seed prompt and contains the same messages as $A$'s but with the roles of $A$ and $B$ swapped. Both have the subcorpus $\subctx$ in the system prompt. To build a training dataset, we sample $\numtrain$ independent conversations and concatenate the messages from $A$ and $B$ into a single sequence of tokens:
\begin{equation}
	\mathcal{D}_\text{train} =
	\{
	\mathbf{x}^{(j)} =
	\mathbf{a}_1^{(j)} \oplus
	\mathbf{b}_1^{(j)} \oplus
	\mathbf{a}_2^{(j)} \oplus
	\mathbf{b}_2^{(j)} \oplus
	\dots \oplus
	\mathbf{a}_k^{(j)} \oplus
	\mathbf{b}_k^{(j)}
	\}_{j=1}^{\numtrain}
    \label{eq:dataset}
\end{equation}
where each $\mathbf{x}^{(j)}$ is a concatentation of the messages.
Note that all of the datasets on which we evaluate in the main paper involve a single-turn. So, we set $k=1$, generating a synthetic conversation with one user message and one assistant message.
Note that the \texttt{chunk} and \texttt{get\_seed\_prompt} functions expose two different ways to control the data distribution of the synthetic data.
We find that these two design decisions are critical for training high quality \artifacts with \method.
\vspace{-2mm}
\paragraph{Chunking}  We use short subcorpora $\tilde{c}$ (between 512 and 4096) tokens to let the LLM focus on different parts of the corpus when generating data.
This is motivated by observations in prior work~\cite{liu2024lost, narayan2025minions}.
Furthermore, chunking also allows us to train \artifacts on corpora longer than the model's context window.
\vspace{-2mm}
\paragraph{Seed prompts}
Instead of using just one seed prompt, we curate a list of five different seed prompt types:     \textit{structuring}, \textit{summarization},
    \textit{question}, \textit{use cases}, and
    \textit{creative}.
The full list of seed prompts used in our experiments is provided in \Cref{app:method}.
Critically, in all our experiments the seed prompts are \textbf{generic}: they do not mention anything related to the specifics of the corpora we evaluated (\eg no mention of translation for MTOB or medical terms for LongHealth).
We use the same set of seed prompts in all of our main results.
In \Cref{sec:results-ablations}, we ablate the use of diverse seed prompts and find that it improves performance over a single generic seed prompt by up to $4.8$ accuracy points ($43.6 \rightarrow 48.4$ on \longhealth).
\ifx\conference\icmlconf
\input{figures/scaling-indexing/scaling-indexing}
\fi
\vspace{-2mm}
\subsection{\method context-distillation objective}
\label{sec:method-objective}
Given a fine-tuning dataset $\mathcal{D}_\text{train}$, we adapt standard techniques from the model distillation literature~\cite{kim2016sequence,snell2022learning,kujanpaa2024knowledge}. We let $\llm(\cdot | \mathbf{x})$ denote the next token distribution given some input text $\mathbf{x}$. Our \textit{teacher} is the model with the subcorpus, $\subctx$, in context $\llm( \cdot | \subctx)$ and our \textit{student} is the same model adapted with a trainable cache   $\llm_{\ctxrep}( \cdot)$.
We use a classic distillation objective~\cite{hinton2015distilling} that minimizes the KL-divergence between the teacher and student next-token distributions over a sequence of tokens $\mathbf{x}$ and the corresponding subcorpus used to generate them $\subctx$.
\vspace{-2mm}
\begin{equation}
    \underset{\ctxrep}{\arg\min} \quad
        \sum_{(\mathbf{x}, \subctx) \in \mathcal{D}_\text{train}}
            \sum_{i=1}^{|\mathbf{x}|}
                D_{\text{KL}}\bigg(
                    \llm( \cdot | \subctx \oplus \mathbf{x}[:i]) \quad || \quad \llm_{\ctxrep}( \cdot | \mathbf{x}[: i])
                \bigg)
\end{equation}
In \Cref{app:results}, ablate the use of the context-distillation objective and show that improves accuracy when controlling for the amount of synthetic data (\eg $3.7$ accuracy points on \longhealth).


% Content from: sections/05_results.tex

\vspace{-2mm}
\section{Results}
\label{sec:results}
\ifx\conference\neuripsconf
\input{figures/tradeoff-within/tradeoff-within}
\fi
\ifx\conference\arxivconf
\input{figures/scaling-indexing/scaling-indexing}
\fi
We describe experiments evaluating the effectiveness of \artifacts trained with \method in various long-context scenarios.
Our results support the following claims.
\textbf{First}, \artifacts trained with \method can match or outperform ICL while maintaining generality and reducing serving costs (\Cref{sec:results-within}).
\textbf{Second}, \method is effective on corpora longer than the context window of the LLM (\Cref{sec:results-extending}).
\textbf{Third}, when we concatenate two different \artifacts without any joint training, the model can respond to queries requiring information from both \artifacts (\Cref{sec:results-composition}).
Finally, we include ablations to assess the relative benefits of different aspects of \method and \artifacts (\Cref{sec:results-ablations}).
\vspace{-2mm}
\paragraph{Datasets} We study datasets consisting of diverse $(\query, \resp)$ pairs about a single long document. Across datasets, $\ctx$ ranges between 100k and 484k tokens. Our datasets are drawn from popular long-context benchmarks, with some used as-released and others modified to meet this structure. These include: \longhealth~\cite{adams2024longhealth}, \mtob~\cite{tanzer2023benchmark}, and QASPER~\cite{dasigi2021dataset}. We evaluate LLM response quality using accuracy for \longhealth, log perplexity for QASPER, and character n-gram f-score (chrF) for MTOB~\cite{tanzer2023benchmark, popovic2015chrf}. Because each dataset effectively consists of a ``single'' document, we train a single \artifact per dataset and evaluate it on the queries response pairs $(\query, \resp)$. \Cref{app:datasets} provides further details.
\ifx\conference\icmlconf
\input{figures/composition/composition}
\fi
\vspace{-2mm}
\subsection{Pushing the quality/cost tradeoff frontier}
\label{sec:results-within}
We assess how \artifacts produced with \method fare in quality and memory consumption against baselines for \longhealth and QASPER on \llamathreeb.
For both datasets, $\ctx$ fits within the model context window ($128$k tokens).
We compare to traditional ICL, two prompt compression baselines (prompt truncation and prompt summarization using GPT-4o  \cite{openai2024gpt4ocard}), and a state-of-the-art KV cache compression baseline (Duo Attention~\cite{jiang-etal-2023-llmlingua,xiao2024duoattention}). We evaluate memory use in terms of KV cache size: the size of the KV cache for the ICL model and prompt compression methods, the size of the \artifact, and the size of the compressed KV cache for KV cache compression methods like DuoAttention.
\Cref{fig:tradeoff-within} presents our main results. On both \longhealth and QASPER, we find cache sizes at which \artifacts outperforms ICL. Compared against ICL, \artifacts offers substantial memory savings at comparable performance: up to $10\times$ for \longhealth,  and up to $100\times$ for QASPER. In contrast, compression baseline methods see performance degradations at compression factors as low as $2\times$. Crucially, the small memory footprint of \artifacts allows for much higher peak throughput (tokens/s).
As \Cref{fig:micros} (right) shows, cache sizes which match performance of ICL allow for almost $26\times$ higher throughput.
\ifx\conference\neuripsconf
\input{figures/scaling-indexing/scaling-indexing}
\fi
\ifx\conference\arxivconf
\input{figures/ablations/ablations}
\fi
We also observe that \artifact performance scales as we increase the amount of compute used in self-study: the longer an \artifact is trained, the greater task performance. \Cref{fig:scaling-indexing} plots the performance for differentially sized \artifacts as a function of the number of training steps. Across all sizes, we observe a steady positive correlation between performance and compute.
\vspace{-2mm}
\subsection{Extending the effective context window}
\label{sec:results-extending}
We evaluate whether \method allows us to accurately process corpora that exceed the context window length.
To study this, we consider the MTOB dataset, and \llamaeightb, which has a context window of $128$k tokens.
MTOB provides two different long documents: a full $484$k token latex textbook and a shorter $60$k token version, which was manually-curated by the dataset authors to exclude content not relevant to the translation task.
Even though the $484$k textbook is $356$k tokens \textit{longer} than \llamaeightb's context window length, we can produce a \artifact for the full textbook using the chunking strategy of \method.
\Cref{fig:tradeoff-within} (middle plot) shows the performance of \artifacts of various sizes trained with \method.
As a point of comparison, we provide the results for KV cache baseline methods on the smaller $60$k token textbook, and also include ICL on a truncated version of the long textbook. Like above, we observe that \artifact can match the performance of ICL on the hand-curated $60$k token version, while requiring substantially less memory and only having access to the $484$k token version, which exceeds the context window of \llamaeightb.
\artifacts also outperform competitive baselines at every KV cache size, by up to 11.0 chrF points.
\vspace{-2mm}
\subsection{Ablating \method design choices}
\label{sec:results-ablations}
We perform ablations to study different aspects of \method and \artifact parameterization.
We provide full results in Appendix \ref{app:results} and highlight key findings here and in \Cref{fig:ablations}.
\paragraph{\artifact Parameterization} In \Cref{sec:artifact-parameterization}, we discuss how we parameterize the \artifact with a trainable KV cache, which is equivalent to a simplified version of prefix tuning~\cite{li2021prefix}.
There are a number of other ways we could parameterize the \artifact, notably low-rank adaptation (LoRA), an extremely popular parameter effcient fine-tuning method~\cite{hu2022lora}.
We compare the prefix-tuning parameterization with LoRA (see \Cref{app:results-parameterization} for full results).
First, we find that the prefix-tuning parameterization is more effective than a memory-matched LoRA parameterization on queries related to the corpus. For example, with \artifacts of size $\sim0.6$ GB on \mtob, prefix-tuning outperforms LoRA by $4.5$ ChRF points. (See \Cref{fig:parameterization} for results on \longhealth and \qasper.)
Even more interesting is the gap between these parameterizations on queries unrelated to the document like MMLU~\cite{hendrycks2020measuring}.
When using a LoRA parameterization, we find that MMLU accuracy drops precipitously (from $54.7$ to $45.3$) as we increase the \artifact size (from 0.15 GB to 1.06 GB). In contrast, with prefix-tuning, the accuracy drops much less rapidly (from $54.7$ to $54.3$) as we increase the size (from 0.15 GB to 0.96 GB).
See \Cref{fig:parameterization} for plots illustrating these findings on \longhealth, \qasper, and \mtob.
We also show that freezing the attention sink (the first token in the key and value vectors) improves training stability (\Cref{fig:freeze}).
\paragraph{\artifact Initialization} We compare three different strategies for initializing the KV cache when using the prefix-tuning parameterization: (1) random vectors (from a component-wise standard normal distribution), (2) key and value vectors of random tokens, and (3) key and value vectors of the first $p$ tokens of the corpus.
We find that initializing with key and value vectors of actual tokens (as opposed to random vectors) is critical for achieving ICL-level performance.
On \longhealth, random vectors achieve an accuracy of $29.9\%$ while key and value vectors of random tokens achieve an accuracy of $51.3\%$.
Initializing with the first $p$ tokens provides an additional improvement of $4$ percentage points to $55.3\%$.
In the original prefix-tuning paper, the authors show that initializing from tokens improves performance when performing supervised fine-tuning on very small datasets~\cite{li2021prefix}. Our results extend this finding to \method, where we train on large synthetic datasets.
\paragraph{\method Seed Prompts} Next, we ablate the choice of \textit{seed prompts} (see Line 2 of \Cref{alg:synthetic-generation}).
We compare two approaches: (1) always using the same seed prompt (\textit{``Please generate a single chat message to begin a conversation about the information in the corpus. Ask a question about the corpus or make a request."}) and (2) randomly sampling one of five different types  of seed prompts (\eg structuring, summarization; see full list in \Cref{app:method-data}). Note even with the latter approach, the seed prompts are generic: the same set of seed prompts are used for all corpora.
On \mtob, we find that using this small set of seed prompts improves over the single seed prompt by 7.9 ChRF points ($24.1 \rightarrow 32.0$; see \Cref{fig:ablations} Left).
On \longhealth, the improvement is $4.8$ accuracy points ($43.6 \rightarrow 48.4$ on \longhealth; see \Cref{fig:seeds}).
Interestingly, on \qasper we do not see any significant benefit from using the diverse seed prompts. This is perhaps because, compared to \longhealth and \mtob, the queries in \qasper are less reasoning intensive.
\paragraph{\method Objective} Finally, we evaluate the importance of the context distillation objective (defined in \Cref{sec:method-objective}).
Using the same \method synthetic data for both objectives, we compare the context-distillation objective with a simpler next-token prediction objective.
On \mtob, we find that using a context distillation objective on the synthetic conversation data improves ChRF by $8.6$ points ($24.9 \rightarrow 33.5$; see \Cref{fig:logits} Center).
We also see improvements on \longhealth and \qasper (see \Cref{fig:logits}).
\vspace{-2mm}
\subsection{Composing \artifacts}
\label{sec:results-composition}
\ifx\conference\neuripsconf
\input{figures/composition/composition}
\fi
\ifx\conference\arxivconf
\input{figures/composition/composition}
\fi
We evaluate if independently trained \artifacts can be \textit{composed} in order to serve queries about two different
corpora (see \Cref{fig:composition}, Left).
We train \artifacts across sizes $\{512, 1024, 2048, 4096\}$ and long 10-K documents from AMD, Pepsi, AMEX, and Boeing~\cite{islam2023financebench}.
For each pair of \artifacts pairwise (6 pairs per cache size), we evaluate using a dataset of \textit{multi-document questions}, i.e., requiring information from both 10-Ks.
Surprisingly, we find composition not only leads to coherent LLM generations \textit{off-the-shelf without any re-training} (\Cref{fig:composition}, Right), but also substantially outperforms the use of a single \artifact (\ie for only AMD) or ICL (which struggles due to context length limits) (\Cref{fig:composition}, Center) on the multi-document questions.
\vspace{-2mm}
\section{Discussion and conclusion}
We propose \artifacts as an alternative to ICL for settings where many different user messages reference the same large corpus of text.
We demonstrate across a diverse set of language model workloads that, when trained via \method, they match ICL's response quality while substantially reducing memory consumption  ($38.6\times$ memory reduction across our evaluations) and increasing peak throughput ($26.4\times$ higher tokens per second). \artifacts are simple to train, composable, and compatible with existing LLM serving infrastructure.
However, compared with ICL, \method is not without limitations.
Using \method to produce a KV-cache is much more costly than simply running standard ICL pre-fill.
With our unoptimized implementation, training an ICL-quality \artifact takes $\sim30$ minutes on a single $8\times$H100 node (for \llamaeightb)
So our work does not provide a drop-in replacement for ICL, but rather demonstrates one way to tradeoff increased compute for reduced memory when constructing a KV-cache.
This tradeoff is extremely advantageous in many settings: users often issue many queries over the same corpus and \method can be trained offline on idle or underutilized compute (\eg at night when user load is low~\cite{jaiswal2025serving,goel2025niyama}).
Furthermore, there is ample room for optimizations (\eg improved shared-prefix attention kernels~\cite{dao2022flashattention,ye2025flashinfer, juravsky2024hydragenhighthroughputllminference}) that would make \method training procedure more efficient.
Looking forward, we envision \artifacts enabling a broad class of context-aware AI applications that are intractable with ICL today, from medical assistants that know a patient's full medical history to LLM-powered IDEs that understand entire codebases.


% Content from: sections/acks.tex

\paragraph{Acknowledgments} We thank Jordan Juravsky, Dan Biderman, Tri Dao, Bradley Brown, Mayee Chen, Avanika Narayan, Avner May, Bill Mark, Benjamin Spector, Roberto Garcia, Quinn Mcintyre, Yasa Baig, Geoff Angus, Kelly Buchanan, Mert Yuksekgonul, Eric Nguyen, Eric Wu, Kevin Wu, Owen Dugan, Jon Saad-Falcon, Simon Guo and the entire Zou, Hazy, and Scaling Intelligence research labs for helpful discussions and feedback.
We gratefully acknowledge Modal, Prime Intellect, Voltage Park, and Together AI for providing the GPUs to support for this work.
We gratefully acknowledge the support of NIH under No. U54EB020405 (Mobilize), NSF under Nos. CCF2247015 (Hardware-Aware), CCF1763315 (Beyond Sparsity), CCF1563078 (Volume to Velocity), and 1937301 (RTML); US DEVCOM ARL under Nos. W911NF-23-2-0184 (Long-context) and W911NF-21-2-0251 (Interactive Human-AI Teaming); ONR under Nos. N000142312633 (Deep Signal Processing); Stanford HAI under No. 247183; NXP, Xilinx, LETI-CEA, Intel, IBM, Microsoft, NEC, Toshiba, TSMC, ARM, Hitachi, BASF, Accenture, Ericsson, Qualcomm, Analog Devices, Google Cloud, Salesforce, Total, the HAI-GCP Cloud Credits for Research program,  the Stanford Data Science Initiative (SDSI), members of the Stanford SEAMS project: IBM and Felicis, as well as members of the Stanford DAWN project: Meta, Google, and VMWare. SE is supported by the NSF Graduate Research Fellowship Program. AR's research is supported by NSF grant CCF\#2247014. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views, policies, or endorsements, either expressed or implied, of NIH, ONR, or the U.S. Government.
\paragraph{Contributions}
SE and RE conceived of \artifacts and \method. SE, RE, and SA designed the method, implemented the experiments, wrote the manuscript, and contributed equally to the project. NG made substantial contributions to the structure of the project and the final manuscript. EL and DZ implemented and ran experiments and made meaningful contributions to the manuscript.
WT implemented the LoRA baselines.
DZ and AR led the theoretical analysis.
AR, JZ, AM, and CR supervised the project.


% Content from: sections/algorithms/synthetic-data.tex

\begin{algorithm}
    \caption{\method: Data Generation}
    \textbf{Input:} $\ctx$ : \texttt{Corpus}, $\llm$ : \texttt{Model}  \\
    \textbf{Output:} $\{\mathbf{a}_1, \mathbf{b}_1, \dots, \mathbf{a}_k, \mathbf{b}_k\}$ :  \texttt{Convo}
    \begin{algorithmic}[1]
    \label{alg:synthetic-generation}
    \State $\subctx \gets$ \texttt{chunk}($\ctx$)  \Comment{\textbf{(1)} Get a \textbf{subcorpus} of $\ctx$ that fits in the context window}
    \State $\seed \gets$ \texttt{get\_seed\_prompt}()  \Comment{\textbf{(2)} Get a prompt to \textbf{seed} the first message from $A$}
    \For{$i = 1$ to $k$} \Comment{\textbf{(3)} Sample a \textbf{conversation} with $k$ back and forths}
        \State $\mathbf{a}_i \sim \llm( \cdot \mid \subctx \oplus \seed \oplus \mathbf{a}_{1} \oplus \dots \oplus \mathbf{b}_{i-1})$  \Comment{\textbf{(3.1)} Sample $A$'s message with $\subctx$ and $\seed$ in context}
        \State $\mathbf{b}_i \sim \llm( \cdot \mid \subctx \oplus \mathbf{a}_{1} \oplus \dots \oplus \mathbf{b}_{i-1} \oplus \mathbf{a}_{i})$  \Comment{\textbf{(3.2)} Sample $B$'s message with $\subctx$ in context}
    \EndFor
    \State \textbf{return} $ \{\mathbf{a}_1, \mathbf{b}_1, \dots, \mathbf{a}_k, \mathbf{b}_k\}$
    \end{algorithmic}
    \end{algorithm}
